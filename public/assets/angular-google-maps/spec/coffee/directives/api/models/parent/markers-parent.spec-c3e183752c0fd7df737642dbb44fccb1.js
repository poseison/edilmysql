(function(){var e=[].slice,t={}.hasOwnProperty,r=function(e,r){function s(){this.constructor=e}for(var c in r)t.call(r,c)&&(e[c]=r[c]);return s.prototype=r.prototype,e.prototype=new s,e.__super__=r.prototype,e};xdescribe("MarkersParentModel",function(){return beforeEach(function(){return angular.mock.module("google-maps.directives.api.models.parent",function(t){return function(s){var c,i,a;return t.provide=s,a=function(){function t(){var t;t=1<=arguments.length?e.call(arguments,0):[],this.args=t,this.constructed=!0,this.drawCalled=0,this.clearCalled=0,this.fitCalled=0}return t.prototype.draw=function(){return this.drawCalled++},t.prototype.clear=function(){return this.clearCalled++},t.prototype.fit=function(){return this.fitCalled++},t}(),c=function(t){function s(){var t;t=1<=arguments.length?e.call(arguments,0):[],s.__super__.constructor.call(this,t),this.constructed=!0,this.childConstructed=!0}return r(s,t),s}(a),i=function(){function t(){var t;t=1<=arguments.length?e.call(arguments,0):[],this.args=t,this.constructed=!0}return t}(),t.clustererMarkerManager=c,t.markerManager=a,t.markerChildModel=i,t.provide.decorator("ClustererMarkerManager",function(){return t.clustererMarkerManager}),t.provide.decorator("MarkerManager",function(){return t.markerManager}),t.provide.decorator("MarkerChildModel",function(){return t.markerChildModel})}}(this)),this.clickCount=0,inject(function(e){return function(t,r,s,c,i,a,o){return e.rootScope=t,e.scope=t.$new(),e.ele=s('<markers models="models"></markers>')(e.scope),e.attrs={click:e.click},e.MarkersParentModel=o,e.$timeout=r,e.scope.click=function(){return e.clickCount++}}}(this)),this.map=jasmine.createSpyObj("map"),this.subject=new this.MarkersParentModel(this.scope,this.ele,this.attrs,this.map,this.$timeout)}),it("should instantiate",function(){return expect(null!=this.subject).toEqual(!0)}),it("should validate a scope correctly",function(){return expect(this.subject.validateScope(this.scope)).toEqual(!0),this.scope.models=[{latitude:47,longitude:-27}],expect(this.subject.validateScope(this.scope)).toEqual(!1),this.scope.coords={latitude:47,longitude:-27},expect(this.subject.validateScope(this.scope)).toEqual(!0)}),it("should watch the appropriate properties on timeout",function(){var e,t;return t=[],e="models doCluster clusterOptions clusterEvents fit idKey".split(" "),this.scope.$watch=function(){return function(e){return t.push(e)}}(this),spyOn(this.subject,"createMarkersFromScratch"),this.subject.onTimeOut(this.scope),expect(this.subject.createMarkersFromScratch).toHaveBeenCalled()}),describe("watch tests",function(){return beforeEach(function(){return spyOn(this.subject,"reBuildMarkers"),spyOn(this.subject,"pieceMealMarkers"),this.idKey=this.subject.idKey}),it("should watch rebuild markers and not change idKey",function(){return this.subject.onWatch("foo",this.scope,"baz","bar"),expect(this.subject.idKey).toEqual(this.idKey),expect(this.subject.pieceMealMarkers).not.toHaveBeenCalled(),expect(this.subject.reBuildMarkers).toHaveBeenCalled()}),it("should watch and rebuild markers, but change idKey",function(){return this.subject.onWatch("idKey",this.scope,"foo",this.idKey),expect(this.subject.idKey).toEqual("foo"),expect(this.subject.pieceMealMarkers).not.toHaveBeenCalled(),expect(this.subject.reBuildMarkers).toHaveBeenCalled()}),it("should watch and build piecemeal and not change idKey",function(){return this.subject.doRebuildAll=!1,this.subject.onWatch("foo",this.scope,"foo",this.idKey),expect(this.subject.idKey).toEqual(this.idKey),expect(this.subject.pieceMealMarkers).toHaveBeenCalled(),expect(this.subject.reBuildMarkers).not.toHaveBeenCalled()}),it("should watch and build piecemeal and change idKey",function(){return this.subject.doRebuildAll=!1,this.subject.onWatch("idKey",this.scope,"foo",this.idKey),expect(this.subject.idKey).toEqual("foo"),expect(this.subject.pieceMealMarkers).toHaveBeenCalled(),expect(this.subject.reBuildMarkers).not.toHaveBeenCalled()})}),describe("createMarkers from scratch tests",function(){return beforeEach(function(){return spyOn(this.subject,"newChildMarker"),this.subject.gMarkerManager=new this.clustererMarkerManager}),it("should call ClustererMarkerManager",function(){return this.scope.doCluster=!0,this.scope.clusterOptions={},this.subject.createMarkersFromScratch(this.scope),expect(this.subject.gMarkerManager.childConstructed).toEqual(!0)}),it("should call not call ClustererMarkerManager when markerManager is set and options are the same as scope options",function(){return this.scope.doCluster=!0,this.scope.clusterOptions={},this.subject.gMarkerManager.opt_options=this.scope.clusterOptions,this.subject.gMarkerManager.childConstructed=!1,this.subject.createMarkersFromScratch(this.scope),expect(this.subject.gMarkerManager.childConstructed).toEqual(!1)}),it("should call ClustererMarkerManager when markerManager is set and options options are not the same",function(){return this.scope.doCluster=!0,this.scope.clusterOptions={},this.subject.gMarkerManager.childConstructed=!1,this.subject.createMarkersFromScratch(this.scope),expect(this.subject.gMarkerManager.childConstructed).toEqual(!0)}),it("should call clustererMarkerManager when doCluster is true and no clusterOptions set",function(){return this.scope.doCluster=!0,this.subject.createMarkersFromScratch(this.scope),expect(this.subject.gMarkerManager.childConstructed).toEqual(!0),expect(this.subject.gMarkerManager.args.length).toEqual(1)}),it("should call generic MarkerManager when no cluster options are set",function(){return this.subject.createMarkersFromScratch(this.scope),expect(this.subject.gMarkerManager.childConstructed).toEqual(void 0)}),it("should call newChildMarker for each model and fit should not be called",function(){return this.scope.models=[{},{}],this.subject.createMarkersFromScratch(this.scope),expect(this.subject.newChildMarker.calls.length).toEqual(2),expect(this.subject.gMarkerManager.fitCalled).toBe(0)})}),describe("Rebuild markers",function(){return this.beforeEach(function(){return spyOn(this.subject,"onDestroy"),spyOn(this.subject,"createMarkersFromScratch")}),it("should return without doRebuild",function(){return this.scope.doRebuild=!1,this.subject.reBuildMarkers(this.scope),expect(this.subject.onDestroy).not.toHaveBeenCalled()}),it("should call on destroy and createMarkersFromScratch",function(){return this.subject.reBuildMarkers(this.scope),expect(this.subject.onDestroy).toHaveBeenCalled(),expect(this.subject.createMarkersFromScratch).toHaveBeenCalled()})}),describe("pieceMealMarkers",function(){return this.beforeEach(function(){return spyOn(this.subject,"figureOutState"),spyOn(this.subject,"reBuildMarkers"),spyOn(this.subject,"newChildMarker")}),it("should call reBuildMarkers",function(){return this.subject.pieceMealMarkers(this.scope),expect(this.subject.reBuildMarkers).toHaveBeenCalled()}),it("should call figureOutState",function(){return this.scope.models=[{}],this.scope.markerModels=[{}],this.subject.pieceMealMarkers(this.scope),expect(this.subject.figureOutState).toHaveBeenCalled()})}),describe("newChildMarker",function(){return it("should return undefined, but call constructor",function(){return expect(this.subject.newChildMarker({},this.scope)).toEqual(void 0)}),it("should return a new childMarker",function(){var e,t;return t={},t[this.subject.idKey]="foo",this.scope.markerModels={put:function(){}},spyOn(this.scope.markerModels,"put"),e=this.subject.newChildMarker(t,this.scope),expect(e.constructed).toEqual(!0),expect(this.scope.markerModels.put.calls[0].args[0]).toEqual("foo"),expect(this.scope.markerModels.put.calls[0].args[1]).toEqual(e)})}),describe("onDestroy",function(){return it("should succeed",function(){return this.subject.onDestroy(this.scope)})}),describe("fit",function(){return it("should succeed",function(){return this.subject.gMarkerManager=new this.clustererMarkerManager,this.subject.gMarkerManager.fit()})})})}).call(this);